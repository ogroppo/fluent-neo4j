require('isitnot')
const {formatNode, formatNodeAliasLabels, nodeMetaFields} = require('./lib/node')
const {formatRel, relMetaFields} = require('./lib/rel')
const {
	formatProps, 
	formatPropKeys, 
	formatPropRegex, 
	formatCreatedAt, 
	formatUpdatedAt, 
	formatMatchedAt, 
	formatMatchCount, 
	formatOrderBy
} = require('./lib/props')
const {formatAlias} = require('./lib/alias')
const {formatJoin} = require('./lib/utils')

module.exports = class CypherQuery{
	constructor(config = {}){
		this.queryString = ''
		this.queryParams = {}
		this.debug = config.debug
	}

	_newLine(message = ''){
		if(this.debug)
			this.queryString += `${message}\n`
	}

	_node(node = {}){
		if(isStringAndNotEmpty(node.label)){	
			node.labels = node.labels || []
			node.labels.push(node.label)
		}

		let paramMap = {}
		for(let prop in node){
			if(nodeMetaFields.includes(prop))
				continue

			let propKey = prop + Object.keys(this.queryParams).length
			this.queryParams[propKey] = node[prop]
			paramMap[prop] = propKey
		}

		return formatNode(node, paramMap)
	}

	_rel(rel = {}){
		let paramMap = {}
		for(let prop in rel){
			if(relMetaFields.includes(prop))
				continue

			let propKey = prop + Object.keys(this.queryParams).length
			this.queryParams[propKey] = rel[prop]
			paramMap[prop] = propKey
		}

		return formatRel(rel, paramMap)
	}

	_pattern(parentNode, rel, childNode){
		return this._node(parentNode)+this._rel(rel)+this._node(childNode)
	}

	_getCurrentNodeAlias(alias){
		if(alias && isNotVariableName(alias))
			throw "Not valid node alias"

		let currentNodeAlias = alias || 'node'

		if(!this.nodeAliases){
			this.nodeAliases = [currentNodeAlias]
		}else{
			if(this.nodeAliases.includes(currentNodeAlias)){
				let existingCount = this.nodeAliases.filter((alias) => alias.startsWith(currentNodeAlias)).length
				currentNodeAlias += existingCount
			}
			
			this.nodeAliases.push(currentNodeAlias)
		}

		this.currentAlias = currentNodeAlias
		return currentNodeAlias
	}

	_getCurrentRelAlias(alias){
		if(alias && isNotVariableName(alias))
			throw "Not valid rel alias"

		let currentRelAlias = alias || 'rel'

		if(!this.relAliases){
			this.relAliases = [currentRelAlias]
		}else{
			if(this.relAliases.includes(currentRelAlias)){
				let existingCount = this.relAliases.filter((alias) => alias.startsWith(currentRelAlias)).length
				currentRelAlias += existingCount
			}
			
			this.relAliases.push(currentRelAlias)
		}
		
		this.currentAlias = currentRelAlias
		return currentRelAlias;
	}

	_getPreviousNodeAlias(){
		return this.nodeAliases[this.nodeAliases.length - 2]
	}

	and(...args){
		this.where(...args)

		return this
	}

	create(...patterns){
		this.queryString += `CREATE `
		if(patterns.length){
			this.queryString += `${formatJoin(patterns)} `
			this._newLine()
		}

		return this
	}

	createNode(node = {}, options = {}){
		if(isNotObject(node))
			throw "createNode: node must be object"

		node.alias = this._getCurrentNodeAlias(node.alias)

		this.create(this._node(node))
		
		this.set(formatCreatedAt(node))
		
		return this
	}

	limit(amount){
		if(amount && parseInt(amount)){
			this.queryString += `LIMIT ${parseInt(amount)} `
			this._newLine()
		}

		return this
	}

	match(...patterns){
		this.queryString += `MATCH `
		if(patterns.length){
			this.queryString += `${formatJoin(patterns)} `
			this._newLine()
		}
		this.whereClauseUsed = false

		return this
	}

	matchChild(node = {}, options = {}){

		node.alias = this._getCurrentNodeAlias(node.alias || 'child')

		var previousNode = {alias: this._getPreviousNodeAlias()} 
		
		this.optional(options.optional)
		
		this.match(this._node(previousNode)+this._rel(options.rel)+this._node(node))

		return this
	}	

	matchNode(node = {}, options = {}){
		if(isNotObject(node))
			throw "matchNode: node must be object"

		node.alias = this._getCurrentNodeAlias(node.alias)
		
		this.optional(options.optional)
		this.match(this._node(node))

		let removes = []
		if(options.removeProps)
			removes.push(formatPropKeys(node, options.removeProps))

		if(options.removeLabels)
			removes.push(formatNodeAliasLabels(node, options.removeLabels))

		this.remove(...removes)

		let sets = []
		if(options.setProps)
			sets.push(formatProps(node, options.setProps))

		if(options.setLabels)
			sets.push(formatNodeAliasLabels(node, options.setLabels))

		if(sets.length || removes.length){
			sets.push(formatUpdatedAt(node))
			if(options.userId)
				sets.push(formatUpdatedBy(node))
		}

		this.set(...sets)
		
		return this
	}

	matchPath(options = {}){
		
		options.pathAlias = options.pathAlias || 'path'

		options.parentNode = {
			alias: 'parent'
		}

		options.rel = options.rel || {}
		options.rel.depth = options.rel.depth || '*'

		options.childNode = {
			alias: 'child'
		}

		this.match(options.pathAlias + " = "+this._node(options.parentNode)+this._rel(options.rel)+this._node(options.childNode))

		return this
	}

	matchParent(node = {}, options = {}){

		node.alias = this._getCurrentNodeAlias(node.alias || 'parent')

		var previousNode = {alias: this._getPreviousNodeAlias()} 
		
		this.optional(options.optional)
		
		this.match(this._node(node)+this._rel(options.rel)+this._node(previousNode))

		return this
	}

	matchRel(rel = {}, options = {}){
		if(isNotObject(rel))
			throw "matchRel: rel must be object"

		rel.alias = this._getCurrentRelAlias(rel.alias)

		this.optional(options.optional)
		this.match(this._pattern({alias: options.startAlias}, rel, {alias: options.endAlias}))

		let removes = []
		if(options.removeProps)
			removes.push(formatPropKeys(rel, options.removeProps))

		this.remove(...removes)

		let sets = []
		if(options.setProps)
			sets.push(formatProps(rel, options.setProps))

		if(sets.length || removes.length){
			sets.push(formatUpdatedAt(rel))
			if(options.userId)
				sets.push(formatUpdatedBy(rel))
		}

		this.set(...sets)

		return this
	}

	merge(...patterns){
		this.queryString += `MERGE `
		if(patterns.length){
			this.queryString += `${formatJoin(patterns)} `
			this._newLine()
		}

		return this
	}

	mergeChild(childNode = {}, options = {}){

		childNode.alias = this._getCurrentNodeAlias(childNode.alias || 'child')

		const originNode = {alias: this._getPreviousNodeAlias()}

		this.merge(this._node(originNode)+this._rel(options.rel)+this._node(childNode))
		
		return this
	}

	mergeNode(node = {}, options = {}){
		if(isNotObject(node))
			throw "matchNode: node must be object"

		node.alias = this._getCurrentNodeAlias(node.alias)

		this.merge(this._node(node))

		let removes = []
		if(options.removeProps)
			removes.push(formatPropKeys(node, options.removeProps))

		if(options.removeLabels)
			removes.push(formatNodeAliasLabels(node, options.removeLabels))

		this.remove(...removes)

		let sets = []
		if(options.setProps)
			sets.push(formatProps(node, options.setProps))

		if(options.setLabels)
			sets.push(formatNodeAliasLabels(node, options.setLabels))

		if(sets.length || removes.length){
			sets.push(formatUpdatedAt(node))
			if(options.userId)
				sets.push(formatUpdatedBy(node))
		}

		this.set(...sets)
		
		return this
	}

	mergeParent(node = {}, options = {}){

		node.alias = this._getCurrentNodeAlias(node.alias || 'parent')

		const originNode = {alias: this._getPreviousNodeAlias()}

		this.merge(this._node(node)+this._rel(options.rel)+this._node(originNode))
		
		return this
	}

	mergeRel(rel, options = {}){ //it is only a contextual clause
		if(isNotObject(rel))
			throw "mergeRel: rel must be object"

		if(!rel.type)
			throw "mergeRel: rel must have type"

		rel.alias = this._getCurrentRelAlias(rel.alias)
		
		this.merge(this._node({alias: options.parentAlias})+this._rel(rel)+this._node({alias: options.childAlias}))
		
		var onMatchSets = [formatMatchedAt(rel), formatMatchCount(rel)]
		if(options.onMatchSet)
			onMatchSets.push(formatProps(rel, options.onMatchSet))
		this.onMatchSet(...onMatchSets)

		var onCreateSets = [formatCreatedAt(rel)]
		if(options.onCreateSet)
			onCreateSets.push(formatProps(rel, options.onCreateSet))
		
		this.onCreateSet(...onCreateSets)

		var sets = []
		if(options.set)
			sets.push(formatProps(rel, options.set))
		
		this.set(...sets)

		return this
	}

	onCreateSet(...props){
		if(props.length){
			this.queryString += `ON CREATE SET ${formatJoin(props)} `
			this._newLine();
		}

		return this
	}

	onMatchSet(...props){
		if(props.length){
			this.queryString += `ON MATCH SET ${formatJoin(props)} `
			this._newLine();
		}

		return this
	}

	optional(optional){
		if(optional)
			this.queryString += `OPTIONAL `

		return this
	}

	optionalMatchNode(node = {}, options = {}){
		options.optional = true;
		this.matchNode(node, options)
	}

	optionalMatchRel(rel = {}, options = {}){
		options.optional = true;
		this.matchRel(rel, options)
	}

	or(...args){
		if(args.length){
			if(!this.whereClauseUsed){
				this.queryString += `WHERE `
				this.whereClauseUsed = true
			}else{
				this.queryString += `OR `
			}

			this.queryString += `${args.join(' OR ')} `
			this._newLine()
		}

		return this
	}

	orderBy(...props){
		if(props.length){
			this.queryString += `ORDER BY ${formatOrderBy(props)} `
			this._newLine()
		}

		return this
	}

	remove(...props){
		if(props.length){
			this.queryString += `REMOVE ${formatJoin(props)} `
			this._newLine()
		}

		return this
	}

	return(...aliases){
		if(aliases.length){
			this.queryString += `RETURN ${formatAlias(aliases)} `
		}

		return this
	}

	returnAll(){
		this.queryString += `RETURN * `

		return this
	}

	returnDistinct(...aliases){
		if(aliases.length){
			this.queryString += `RETURN DISTINCT ${formatAlias(aliases)} `
		}

		return this
	}

	returnNode(nodeAlias = ''){
		if(isNotString(nodeAlias))
			throw "Error: returnNode - nodeAlias must be string"

		this.queryString += `RETURN `
		if(nodeAlias)
			this.queryString += `${nodeAlias} as `

		this.queryString += `node `

		return this
	}

	returnRel(relAlias = ''){
		if(isNotString(relAlias))
			throw "Error: returnRel - relAlias must be string"

		this.queryString += `RETURN `
		if(relAlias)
			this.queryString += `${relAlias} as `

		this.queryString += `rel `

		return this
	}

	set(...props){
		if(props.length){
			this.queryString += `SET ${formatJoin(props)} `
			this._newLine()
		}

		return this
	}

	skip(amount){
		if(amount && parseInt(amount)){
			this.queryString += `SKIP ${parseInt(amount)} `
			this._newLine()
		}

		return this
	}

	union(){
		this.queryString += `UNION `
		this._newLine()

		return this
	}

	unionAll(){
		this.queryString += `UNION ALL `
		this._newLine()

		return this
	}

	where(...args){
		if(args.length){
			if(!this.whereClauseUsed){
				this.queryString += `WHERE `
				this.whereClauseUsed = true
			}else{
				this.queryString += `AND `
			}

			this.queryString += `${args.join(' AND ')} `
			this._newLine()
		}

		return this
	}

	whereProp(prop){
		if(prop){
			this.where(formatProps({alias: this.currentAlias}, prop))
		}

		return this
	}

	wherePropGreater(prop){
		if(prop){
			this.where(formatProps({alias: this.currentAlias}, prop, ">"))
		}

		return this
	}

	wherePropIn(prop){
		if(prop){
			this.where(formatProps({alias: this.currentAlias}, prop, "IN"))
		}

		return this
	}

	with(...args){
		if(args.length){
			this.queryString += `WITH ${formatJoin(args)} `
			this._newLine()
		}

		return this
	}

	xor(...args){
		if(args.length){
			if(!this.whereClauseUsed){
				this.queryString += `WHERE `
				this.whereClauseUsed = true
			}else{
				this.queryString += `XOR `
			}

			this.queryString += `${args.join(' XOR ')} `
			this._newLine()
		}

		return this
	}

}